%% maneuvering.dg
%% Also include sectored-grid.dg when compiling or debugging.

%%-------------------------------- INTERFACES --------------------------------

(interface (update $<Ship))

(interface (move $<Ship for $<Ticks minutes))

(interface (move $<Ship randomly))

(interface (attract nearby ships to $<Object))

%%------------------------------ IMPLEMENTATION ------------------------------

(turn $Ship to helm setting)
	($Ship effective turn mode $Mode)
	($Ship helm setting $Helm)
	(turn $Ship $Mode toward heading $Helm)

(accelerate $Ship to throttle setting)
	($Ship speed $Speed)
	($Ship throttle setting $Throttle)
	(if) ($Speed < $Throttle) (then)
		($Ship acceleration $Accel)
		($Accel times 100 into $Acceleration)
		($Speed plus $Acceleration into $MaxSpeed)
		(if) ($MaxSpeed > $Throttle) (then)
			($NewSpeed = $Throttle)
		(else)
			($NewSpeed = $MaxSpeed)
		(endif)
	(else)
		($NewSpeed = $Throttle)
	(endif)
	(accelerate $Ship to speed $NewSpeed) 

($Ship should move $Result)
	($Ship state is $State)
	($Ship destination $Destination)
	(calculate range from $State to $Destination into $Range)
	($Ship speed $Distance)
	(if) ($Range > $Distance) (then)
		($Result = $Distance)
	(else)
		($Result = $Range)
	(endif)

($Ship energy needed for distance $Distance into $Result)
	($Ship drive efficiency $Efficiency)
	($Distance divided by $Efficiency into $Dividend)
	($Distance modulo $Efficiency into $Remainder)
	(if) ($Remainder > 0) (then)
		($Dividend plus 1 into $Energy)
	(else)
		($Dividend = $Energy)
	(endif)
	($Distance divided by 100 into $Gradient)
	($Ship cruising speed $Cruising)
	(if) ($Gradient > $Cruising) (then)
		($Gradient minus $Cruising into $Difference)
		($Difference plus 1 into $Multiplier)
		($Energy times $Multiplier into $Result)
	(else)
		($Result = $Energy)
	(endif)

%% random result unless ship is low energy, but never called if it isn't
($Ship can move $Distance with remaining energy)
	($Ship energy $Energy)
	($Ship drive efficiency $Efficiency)
	($Energy times $Efficiency into $Distance)

(move $Ship toward destination)
	($Ship destination $Destination)
	($Ship should move $Distance)
	($Ship energy needed for distance $Distance into $Needed)
	($Ship energy $Energy)
	(if) ($Energy < $Needed) (then)
		($Ship can move $Remaining with remaining energy)
		(move $Ship $Remaining toward position $Destination)
		(decrease energy for $Ship by $Energy)
	(else)
		(move $Ship $Distance toward position $Destination)
		(decrease energy for $Ship by $Needed)
	(endif)
	(if) ($Distance = 0) (or) ($Energy < $Needed) (then)
		(accelerate $Ship to speed 0)
	(endif)

(update $Ship)
	(turn $Ship to helm setting)
	(accelerate $Ship to throttle setting)
	(move $Ship toward destination)
	(regenerate energy for $Ship)

(move $Ship for $Ticks minutes)
	($Ticks > 0)
	(update $Ship)
	($Ticks minus 1 into $Remaining)
	(move $Ship for $Remaining minutes)

(move $Ship randomly)
	($Ship subsector into $SX $SY $ $)
	(random from 1 to 10 into $X)
	(random from 1 to 10 into $Y)
	(random from 1 to 10 into $PX)
	(random from 1 to 10 into $PY)
	(set destination for $Ship to $SX $SY $X $Y $PX $PY)

(attract nearby ships to $Object)
	($Object subsector into $SX $SY $X $Y)
	(exhaust) {
		*(ship $Ship)
		($Ship subsector into $SX $SY $X $Y)
		(drag $Ship 12 toward $Object)
	}
	
	